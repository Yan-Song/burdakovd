#include <iostream>
#include <cstring>
#include <string>
#include <cmath>
#include <stack>
#include <queue>
#include <deque>
#include <vector>
#include <algorithm>
#include <map>

#pragma comment(linker, "/STACK:16777216")

#define mset(block,value) memset(block,value,sizeof(block))
#define fo(i,begin,end) for(int i=begin; i<end; i++)
#define foreach(i,x) for(int i=0; i<x.size(); i++)
#define showv(v) foreach(i,v) cout<<v[i]<<" "; cout<<endl
#define ALL(v) v.begin(), v.end()

using namespace std;

typedef long long i64;
typedef vector<int> VI;


int main()
{
    /*
    очевидно, что если в графе есть изолированные вершины, то ответ - 0

    рассмотрим случай, когда изолированных нет.
    
    определившаяся вершина - это человек, которому назначена группа.
    изначально никому ничего не назначено
    
    ИНВАРИАНТ1: нет определившихся вершин,
    все ребра из которых ведут в вершины той же группы
    что и они сами
    ИНВАРИАНТ2:
    любая вершина группы 2 имеет связь хотя бы с одной вершиной группы 1
    
    изначально оба верны, т.к. нет определившихся вершин.
    
    для каждой неопределившейся вершины i:
        если можно отправить её в первую группу,
        и инвариант1 при этом не нарушится - делаем это,                (1)
        иначе отправляем её во вторую группу.

        покажем, что в случае "иначе" инварианты не нарушатся.
    
        все вершины соседние с i уже насыщены
        (второй группы т.к. был верен инвариант2,
        а первой группы т.к. они соединены с вершиной i,
        которую только что отнесли к группе 2) и для них инвариант1 верен
        для текущей вершины инвариант2 верен, так как иначе все её соседи
        принадлежали бы к группе 2, и мы бы отнесли её к первой группе по (1)

        инвариант1 для этой вершины следует из выполненности инварианта2

        таким образом, вершина i определена, и при этом оба инварианта сохранены

    в конце, если все вершины определились, и выполнены оба инварианта
    то разбиение удовлетворяет заданию
    */
    
    return 0;
}
